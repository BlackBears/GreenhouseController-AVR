/*
 * keypad.c
 *
 * Created: 1/2/2012 3:37:53 PM
 *  Author: Owner
 */ 

#include "keypad.h"
#include "i2c.h"
#include "uart-am168.h"
#include <avr/interrupt.h>
#include <avr/pgmspace.h>
#include <util/delay.h>

//  lookup table for key names by column/row
static unsigned char keys[3][4] PROGMEM = {
		{ '1','4','7','*' },
		{ '2','5','8','0' },
		{ '3','6','9','#' }											
};

/************************************************************************/
/* FUNCTION PROTOTYPES                                                  */
/************************************************************************/

void _reverse_interface(Keypad *k);
void _restore_interface(Keypad *k);
u08 _col_index(u08 col_byte);
u08 _row_index(u08 row_byte);

//
//  Initialize the keypad
//
void keypad_init(Keypad *k,u08 address)
{
	i2cInit();
	
	//  create the I2C interface that our keypad will use & assign address
	MCP23008 interface;
	mcp23008_init(&interface,address);
	k->interface = interface;
	
	//  we start in normal/resting state
	k->state = KeypadStateNormal;
	
	//  setup our outputs and pullups
	_keypad_write_outputs(k);
	//  configure remaining registers
	_restore_interface(k);
}

//
//  Read the keypad, returning the ASCII code
//  generated by the row/col combination on the matrix
//  This should be called by the interrupt service routine
//
u08 keypad_read(Keypad *k) {
	//  get our interface
	MCP23008 interface = k->interface;
	//	obtain the row value
	u08 row = mcp23008_read_register(&interface,MCP23008_INTCAP);
	//	reconfigure to read columns
	_reverse_interface(k);
	//	read the column value
	u08 col = mcp23008_read_register(&interface,MCP23008_GPIO);
	//	obtain the row/col indices
	u08 col_index = _col_index(col);
	u08 row_index = _row_index(row);
	u08 key_val = pgm_read_byte(&keys[col_index][row_index]);
	
	//	restore the interface
	_restore_interface(k);
	k->state = KeypadStateButtonDown;
	return key_val;
}

u08 keypad_update(Keypad *k) {
    if( k->state == KeypadStateButtonDown )
    {
        //	attempt to clear the interrupt
        MCP23008 interface = k->interface;
        u08 temp = mcp23008_read_register(&interface,MCP23008_INTCAP);
		_delay_us(10);
		_keypad_clear_interrupt(k);
		_delay_us(10);
        //	read interrupt flag, if is 0x00, then put our state back to normal
        temp = mcp23008_read_register(&interface,MCP23008_INTF);
        if( !temp )
        {
            EIMSK |= (1<<INT1);
            k->state = KeypadStateNormal;
            return 1;
        }	
    }
	return 0;
}

void _keypad_write_outputs(Keypad *k)
{
	MCP23008 interface = k->interface;
	//  setup our outputs and pullups
	mcp23008_write_register(&interface,MCP23008_GPIO,0xF0);
	mcp23008_write_register(&interface,MCP23008_GPPU,0x0F);
}

void _keypad_clear_interrupt(Keypad *k)
{
	MCP23008 interface = k->interface;
    u08 temp = mcp23008_read_register(&interface,MCP23008_INTCAP);
}

void _reverse_interface(Keypad *k)
{
	MCP23008 interface = k->interface;
	mcp23008_write_register(&interface,MCP23008_IODIR,0x0F);
	mcp23008_write_register(&interface,MCP23008_INTCON,0x0F);
	mcp23008_write_register(&interface,MCP23008_DEFVAL,0x0F);
	mcp23008_write_register(&interface,MCP23008_GPINTEN,0x0F);
	mcp23008_write_register(&interface,MCP23008_GPIO,0x0F);
}

void _restore_interface(Keypad *k) {
	MCP23008 interface = k->interface;
	mcp23008_write_register(&interface,MCP23008_GPIO,0xF0);
	mcp23008_write_register(&interface,MCP23008_IODIR,0xF0);
	mcp23008_write_register(&interface,MCP23008_INTCON,0xF0);
	mcp23008_write_register(&interface,MCP23008_DEFVAL,0xF0);
	mcp23008_write_register(&interface,MCP23008_GPINTEN,0xF0);
}

//
//  Obtain the column index from the column byte byte
//
u08 _col_index(u08 col_byte) {
	return (col_byte == 0x0E)?0:(col_byte == 0x0D)?1:2;
}

//
//  Obtain the row index from the row byte
//
u08 _row_index(u08 row_byte) {
	return (row_byte == 0x70)?0:(row_byte == 0xB0)?1:(row_byte == 0xD0)?2:3;
}